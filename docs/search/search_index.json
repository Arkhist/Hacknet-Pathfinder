{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hacknet Pathfinder Hacknet Pathfinder is a cross-platform modding system for Hacknet. Automatic Install Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux and MacOS, run PathfinderInstaller.py Manual Install Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux/MacOS users, mono PathfinderPatcher.exe ) Rename Hacknet.exe into OldHacknet.exe Rename HacknetPathfinder.exe into Hacknet.exe Running Hacknet Pathfinder runs as normal Hacknet, there is no change. Installing global mods Move the global mod contents into Hacknet/BepInEx/plugins . Troubleshooting [Windows] System.NotSupportedException on launch More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"Home"},{"location":"#hacknet-pathfinder","text":"Hacknet Pathfinder is a cross-platform modding system for Hacknet.","title":"Hacknet Pathfinder"},{"location":"#automatic-install","text":"Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux and MacOS, run PathfinderInstaller.py","title":"Automatic Install"},{"location":"#manual-install","text":"Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux/MacOS users, mono PathfinderPatcher.exe ) Rename Hacknet.exe into OldHacknet.exe Rename HacknetPathfinder.exe into Hacknet.exe","title":"Manual Install"},{"location":"#running","text":"Hacknet Pathfinder runs as normal Hacknet, there is no change.","title":"Running"},{"location":"#installing-global-mods","text":"Move the global mod contents into Hacknet/BepInEx/plugins .","title":"Installing global mods"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#windows-systemnotsupportedexception-on-launch","text":"More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"[Windows] System.NotSupportedException on launch"},{"location":"contributing/","text":"Contributing Compiling and installing Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild or xbuild in root folder) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins Adding features Branch off the master branch, program your feature and send the dev team a Pull Request!","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#compiling-and-installing","text":"Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild or xbuild in root folder) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins","title":"Compiling and installing"},{"location":"contributing/#adding-features","text":"Branch off the master branch, program your feature and send the dev team a Pull Request!","title":"Adding features"},{"location":"mod/actions/","text":"Custom actions Implemented, not documented yet.","title":"Actions"},{"location":"mod/actions/#custom-actions","text":"Implemented, not documented yet.","title":"Custom actions"},{"location":"mod/administrators/","text":"New administrators public class CustomAdministrator : BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } } Registration Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>(); Adding the administrator to a computer <admin type=\"CustomAdministrator\" />","title":"Administrators"},{"location":"mod/administrators/#new-administrators","text":"public class CustomAdministrator : BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } }","title":"New administrators"},{"location":"mod/administrators/#registration","text":"Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>();","title":"Registration"},{"location":"mod/administrators/#adding-the-administrator-to-a-computer","text":"<admin type=\"CustomAdministrator\" />","title":"Adding the administrator to a computer"},{"location":"mod/commands/","text":"Creating custom commands New command public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); } Registration Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Commands"},{"location":"mod/commands/#creating-custom-commands","text":"","title":"Creating custom commands"},{"location":"mod/commands/#new-command","text":"public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); }","title":"New command"},{"location":"mod/commands/#registration","text":"Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Registration"},{"location":"mod/daemons/","text":"Creating custom daemons Base daemon public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } } Registration Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>(); XML Storage XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString; Adding a custom daemon in a computer <CustomDaemon DisplayString=\"XML Edited test\" />","title":"Daemons"},{"location":"mod/daemons/#creating-custom-daemons","text":"","title":"Creating custom daemons"},{"location":"mod/daemons/#base-daemon","text":"public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } }","title":"Base daemon"},{"location":"mod/daemons/#registration","text":"Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>();","title":"Registration"},{"location":"mod/daemons/#xml-storage","text":"XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString;","title":"XML Storage"},{"location":"mod/daemons/#adding-a-custom-daemon-in-a-computer","text":"<CustomDaemon DisplayString=\"XML Edited test\" />","title":"Adding a custom daemon in a computer"},{"location":"mod/executables/","text":"Creating custom executables The base executable public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public override string GetIdentifier() => \"ExecName\"; public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } } Registration Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); The provided argument corresponds to the replacement tag for extension files. Executable features Exiting Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; } Opening a port, starting a trace The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken(); Drawing in the executable's area The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Executables"},{"location":"mod/executables/#creating-custom-executables","text":"","title":"Creating custom executables"},{"location":"mod/executables/#the-base-executable","text":"public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public override string GetIdentifier() => \"ExecName\"; public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } }","title":"The base executable"},{"location":"mod/executables/#registration","text":"Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); The provided argument corresponds to the replacement tag for extension files.","title":"Registration"},{"location":"mod/executables/#executable-features","text":"","title":"Executable features"},{"location":"mod/executables/#exiting","text":"Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; }","title":"Exiting"},{"location":"mod/executables/#opening-a-port-starting-a-trace","text":"The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken();","title":"Opening a port, starting a trace"},{"location":"mod/executables/#drawing-in-the-executables-area","text":"The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Drawing in the executable's area"},{"location":"mod/missions/","text":"Custom missions goals Implemented, not documented yet.","title":"Missions"},{"location":"mod/missions/#custom-missions-goals","text":"Implemented, not documented yet.","title":"Custom missions goals"},{"location":"mod/ports/","text":"Ports Extension development Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp Protocol list Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32 Plugin development Adding new port defaults You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML. Reading port data Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Ports"},{"location":"mod/ports/#ports","text":"","title":"Ports"},{"location":"mod/ports/#extension-development","text":"Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp","title":"Extension development"},{"location":"mod/ports/#protocol-list","text":"Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32","title":"Protocol list"},{"location":"mod/ports/#plugin-development","text":"","title":"Plugin development"},{"location":"mod/ports/#adding-new-port-defaults","text":"You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML.","title":"Adding new port defaults"},{"location":"mod/ports/#reading-port-data","text":"Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Reading port data"},{"location":"mod/start/","text":"Getting started with Pathfinder Modding Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.0 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started"},{"location":"mod/start/#getting-started-with-pathfinder-modding","text":"Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.0 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started with Pathfinder Modding"}]}