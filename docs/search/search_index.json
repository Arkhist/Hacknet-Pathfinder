{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hacknet Pathfinder Hacknet Pathfinder is a cross-platform modding system for Hacknet. Automatic Install Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux, run PathfinderInstaller.py Manual Install Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux users, mono PathfinderPatcher.exe ). (For Linux) Copy Hacknet.bin.x86(_64) to HacknetPathfinder.bin.x86(_64) and make StartPathfinder.sh executable. Run HacknetPathfinder.exe on Windows or StartPathfinder.sh on Linux to start Pathfinder. Running Hacknet Pathfinder runs as normal Hacknet, there is no change. Installing global mods Move the global mod contents into Hacknet/BepInEx/plugins . Troubleshooting [Windows] System.NotSupportedException on launch More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"Home"},{"location":"#hacknet-pathfinder","text":"Hacknet Pathfinder is a cross-platform modding system for Hacknet.","title":"Hacknet Pathfinder"},{"location":"#automatic-install","text":"Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux, run PathfinderInstaller.py","title":"Automatic Install"},{"location":"#manual-install","text":"Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux users, mono PathfinderPatcher.exe ). (For Linux) Copy Hacknet.bin.x86(_64) to HacknetPathfinder.bin.x86(_64) and make StartPathfinder.sh executable. Run HacknetPathfinder.exe on Windows or StartPathfinder.sh on Linux to start Pathfinder.","title":"Manual Install"},{"location":"#running","text":"Hacknet Pathfinder runs as normal Hacknet, there is no change.","title":"Running"},{"location":"#installing-global-mods","text":"Move the global mod contents into Hacknet/BepInEx/plugins .","title":"Installing global mods"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#windows-systemnotsupportedexception-on-launch","text":"More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"[Windows] System.NotSupportedException on launch"},{"location":"contributing/","text":"Contributing Compiling and installing Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild 1 or xbuild in root folder or specically against PathfinderPatcher.csproj) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild 1 or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins Adding features Branch off the master branch, program your feature and send the dev team a Pull Request! msbuild is broken on Arch unless you use mono-git from the AUR, see this bug report . \u21a9 \u21a9","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#compiling-and-installing","text":"Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild 1 or xbuild in root folder or specically against PathfinderPatcher.csproj) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild 1 or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins","title":"Compiling and installing"},{"location":"contributing/#adding-features","text":"Branch off the master branch, program your feature and send the dev team a Pull Request! msbuild is broken on Arch unless you use mono-git from the AUR, see this bug report . \u21a9 \u21a9","title":"Adding features"},{"location":"mod/actions/","text":"Custom actions Base action public class CustomAction : Pathfinder.Action.PathfinderAction { [XMLStorage] public string Attribute1; [XMLStorage] public string Attribute2 = \"Default value!\"; public override void Trigger (object os_obj) { OS os = (OS)os_obj; os.write(\"Custom action triggered!\"); os.write(Attribute1); os.write(Attribute2); } } Delayable action DelayablePathfinderAction is a subtype of PathfinderAction that implements the DelayHost and Delay attributes. public class CustomDelayableAction : Pathfinder.Action.DelayablePathfinderAction { public override void Trigger (OS os) { if (DelayHost != null) { os.write(\"Custom action triggered after \" + Delay + \" seconds with host \" + DelayHost + \"!\"); } } } Registration Actions can be registered manually or with the Action attribute. Pathfinder.Action.ActionManager.RegisterAction<CustomAction>(\"CustomActionXMLTag\"); [Pathfinder.Meta.Load.Action(\"CustomActionXMLTag\")] public class CustomAction : PathfinderAction Adding a custom action to an actions file <CustomActionXMLTag Attribute1=\"Value\" />","title":"Actions"},{"location":"mod/actions/#custom-actions","text":"","title":"Custom actions"},{"location":"mod/actions/#base-action","text":"public class CustomAction : Pathfinder.Action.PathfinderAction { [XMLStorage] public string Attribute1; [XMLStorage] public string Attribute2 = \"Default value!\"; public override void Trigger (object os_obj) { OS os = (OS)os_obj; os.write(\"Custom action triggered!\"); os.write(Attribute1); os.write(Attribute2); } }","title":"Base action"},{"location":"mod/actions/#delayable-action","text":"DelayablePathfinderAction is a subtype of PathfinderAction that implements the DelayHost and Delay attributes. public class CustomDelayableAction : Pathfinder.Action.DelayablePathfinderAction { public override void Trigger (OS os) { if (DelayHost != null) { os.write(\"Custom action triggered after \" + Delay + \" seconds with host \" + DelayHost + \"!\"); } } }","title":"Delayable action"},{"location":"mod/actions/#registration","text":"Actions can be registered manually or with the Action attribute. Pathfinder.Action.ActionManager.RegisterAction<CustomAction>(\"CustomActionXMLTag\"); [Pathfinder.Meta.Load.Action(\"CustomActionXMLTag\")] public class CustomAction : PathfinderAction","title":"Registration"},{"location":"mod/actions/#adding-a-custom-action-to-an-actions-file","text":"<CustomActionXMLTag Attribute1=\"Value\" />","title":"Adding a custom action to an actions file"},{"location":"mod/administrators/","text":"Custom administrators New administrators public class CustomAdministrator : Pathfinder.Administrator.BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } } Registration Administrator can be registered manually or with the Administrator attribute. Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>(); [Pathfinder.Meta.Load.Administrator] public class CustomAdministrator : BaseAdministrator Adding a custom administrator to a computer <admin type=\"CustomAdministrator\" />","title":"Administrators"},{"location":"mod/administrators/#custom-administrators","text":"","title":"Custom administrators"},{"location":"mod/administrators/#new-administrators","text":"public class CustomAdministrator : Pathfinder.Administrator.BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } }","title":"New administrators"},{"location":"mod/administrators/#registration","text":"Administrator can be registered manually or with the Administrator attribute. Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>(); [Pathfinder.Meta.Load.Administrator] public class CustomAdministrator : BaseAdministrator","title":"Registration"},{"location":"mod/administrators/#adding-a-custom-administrator-to-a-computer","text":"<admin type=\"CustomAdministrator\" />","title":"Adding a custom administrator to a computer"},{"location":"mod/commands/","text":"Creating custom commands New command public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); } Registration Commands can be registered manually or with the Command attribute. Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); [Pathfinder.Meta.Load.Command(\"CommandName\")] public static void TestCommand(OS os, string[] args) Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Commands"},{"location":"mod/commands/#creating-custom-commands","text":"","title":"Creating custom commands"},{"location":"mod/commands/#new-command","text":"public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); }","title":"New command"},{"location":"mod/commands/#registration","text":"Commands can be registered manually or with the Command attribute. Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); [Pathfinder.Meta.Load.Command(\"CommandName\")] public static void TestCommand(OS os, string[] args) Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Registration"},{"location":"mod/conditions/","text":"Custom conditions New conditions public class CustomCondition : Pathfinder.Action.PathfinderCondition { [XMLStorage] public string Attribute; public override bool Check(object os_obj) { OS os = (OS)os_obj; // return true if actions inside condition should be triggered // return false otherwise } } Registration Conditions can be registered manually or with the Condition attribute. Pathfinder.Action.ConditionManager.RegisterCondition<CustomCondition>(\"CustomConditionXMLTag\"); [Pathfinder.Meta.Load.Condition] public class CustomCondition : PathfinderCondition Adding a custom condition to an actions file <CustomConditionXMLTag Attribue=\"value\"> <!-- Actions go here! --> </CustomConditionXMLTag>","title":"Conditions"},{"location":"mod/conditions/#custom-conditions","text":"","title":"Custom conditions"},{"location":"mod/conditions/#new-conditions","text":"public class CustomCondition : Pathfinder.Action.PathfinderCondition { [XMLStorage] public string Attribute; public override bool Check(object os_obj) { OS os = (OS)os_obj; // return true if actions inside condition should be triggered // return false otherwise } }","title":"New conditions"},{"location":"mod/conditions/#registration","text":"Conditions can be registered manually or with the Condition attribute. Pathfinder.Action.ConditionManager.RegisterCondition<CustomCondition>(\"CustomConditionXMLTag\"); [Pathfinder.Meta.Load.Condition] public class CustomCondition : PathfinderCondition","title":"Registration"},{"location":"mod/conditions/#adding-a-custom-condition-to-an-actions-file","text":"<CustomConditionXMLTag Attribue=\"value\"> <!-- Actions go here! --> </CustomConditionXMLTag>","title":"Adding a custom condition to an actions file"},{"location":"mod/daemons/","text":"Creating custom daemons Base daemon public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } } Registration Daemons can be registered manually or with the Daemon attribute. Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>(); [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon XML Storage XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString; Adding a custom daemon to a computer <CustomDaemon DisplayString=\"XML Edited test\" />","title":"Daemons"},{"location":"mod/daemons/#creating-custom-daemons","text":"","title":"Creating custom daemons"},{"location":"mod/daemons/#base-daemon","text":"public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } }","title":"Base daemon"},{"location":"mod/daemons/#registration","text":"Daemons can be registered manually or with the Daemon attribute. Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>(); [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon","title":"Registration"},{"location":"mod/daemons/#xml-storage","text":"XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString;","title":"XML Storage"},{"location":"mod/daemons/#adding-a-custom-daemon-to-a-computer","text":"<CustomDaemon DisplayString=\"XML Edited test\" />","title":"Adding a custom daemon to a computer"},{"location":"mod/executables/","text":"Creating custom executables New executables public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; this.IdentifierName = \"ExecName\"; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } } GameExecutable Implemented, not documented yet. Registration Executables can be registered manually or with the Executable attribute. Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); [Pathfinder.Meta.Load.Executable(\"#PF_BASIC_EXE#\")] public class BasicExecutable : Pathfinder.Executable.BaseExecutable The provided argument corresponds to the replacement tag for extension files. Executable features Exiting Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; } Opening a port, starting a trace The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken(); Drawing in the executable's area The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Executables"},{"location":"mod/executables/#creating-custom-executables","text":"","title":"Creating custom executables"},{"location":"mod/executables/#new-executables","text":"public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; this.IdentifierName = \"ExecName\"; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } }","title":"New executables"},{"location":"mod/executables/#gameexecutable","text":"Implemented, not documented yet.","title":"GameExecutable"},{"location":"mod/executables/#registration","text":"Executables can be registered manually or with the Executable attribute. Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); [Pathfinder.Meta.Load.Executable(\"#PF_BASIC_EXE#\")] public class BasicExecutable : Pathfinder.Executable.BaseExecutable The provided argument corresponds to the replacement tag for extension files.","title":"Registration"},{"location":"mod/executables/#executable-features","text":"","title":"Executable features"},{"location":"mod/executables/#exiting","text":"Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; }","title":"Exiting"},{"location":"mod/executables/#opening-a-port-starting-a-trace","text":"The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken();","title":"Opening a port, starting a trace"},{"location":"mod/executables/#drawing-in-the-executables-area","text":"The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Drawing in the executable's area"},{"location":"mod/missions/","text":"Custom missions goals New mission goals public class CustomMissionGoal : Pathfinder.Mission.PathfinderGoal { [XMLStorage] public string Attribute; public OS os; public CustomMissionGoal() { os = OS.currentInstance; } public override bool isComplete(List<string> additionalDetails = null) { // return true if the mission should be completed // return false otherwise } } Registration Goals can be registered manually or with the Goal attribute. Pathfinder.Goal.GoalManager.RegisterGoal<CustomMissionGoal>(\"CustomGoalName\"); [Pathfinder.Meta.Load.Goal(\"CustomGoalName\")] public class CustomMissionGoal : PathfinderGoal Adding a custom goal to a mission file <goal type=\"CustomGoalName\" Attribute=\"attribute value\" />","title":"Missions"},{"location":"mod/missions/#custom-missions-goals","text":"","title":"Custom missions goals"},{"location":"mod/missions/#new-mission-goals","text":"public class CustomMissionGoal : Pathfinder.Mission.PathfinderGoal { [XMLStorage] public string Attribute; public OS os; public CustomMissionGoal() { os = OS.currentInstance; } public override bool isComplete(List<string> additionalDetails = null) { // return true if the mission should be completed // return false otherwise } }","title":"New mission goals"},{"location":"mod/missions/#registration","text":"Goals can be registered manually or with the Goal attribute. Pathfinder.Goal.GoalManager.RegisterGoal<CustomMissionGoal>(\"CustomGoalName\"); [Pathfinder.Meta.Load.Goal(\"CustomGoalName\")] public class CustomMissionGoal : PathfinderGoal","title":"Registration"},{"location":"mod/missions/#adding-a-custom-goal-to-a-mission-file","text":"<goal type=\"CustomGoalName\" Attribute=\"attribute value\" />","title":"Adding a custom goal to a mission file"},{"location":"mod/ports/","text":"Ports Extension development Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp Protocol list Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32 Plugin development Adding new port defaults You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML. Ports can also be added by using the Port attribute on a field or property. [Pathfinder.Meta.Load.Port] public Pathfinder.Port.PortRecord customPort = new Pathfinder.Port.PortRecord(\"protocol\", \"displayName\", 50); Reading port data Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Ports"},{"location":"mod/ports/#ports","text":"","title":"Ports"},{"location":"mod/ports/#extension-development","text":"Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp","title":"Extension development"},{"location":"mod/ports/#protocol-list","text":"Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32","title":"Protocol list"},{"location":"mod/ports/#plugin-development","text":"","title":"Plugin development"},{"location":"mod/ports/#adding-new-port-defaults","text":"You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML. Ports can also be added by using the Port attribute on a field or property. [Pathfinder.Meta.Load.Port] public Pathfinder.Port.PortRecord customPort = new Pathfinder.Port.PortRecord(\"protocol\", \"displayName\", 50);","title":"Adding new port defaults"},{"location":"mod/ports/#reading-port-data","text":"Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Reading port data"},{"location":"mod/start/","text":"Getting started with Pathfinder Modding Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.5 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started"},{"location":"mod/start/#getting-started-with-pathfinder-modding","text":"Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.5 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started with Pathfinder Modding"}]}