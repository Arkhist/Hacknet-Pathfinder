{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hacknet Pathfinder Hacknet Pathfinder is a cross-platform modding system for Hacknet. Automatic Install Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux, run PathfinderInstaller.py Manual Install Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux users, mono PathfinderPatcher.exe ). (For Linux) Copy Hacknet.bin.x86(_64) to HacknetPathfinder.bin.x86(_64) and make StartPathfinder.sh executable. Run HacknetPathfinder.exe on Windows or StartPathfinder.sh on Linux to start Pathfinder. Running Hacknet Pathfinder runs as normal Hacknet, there is no change. Installing global mods Move the global mod contents into Hacknet/BepInEx/plugins . Troubleshooting [Windows] System.NotSupportedException on launch More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"Home"},{"location":"#hacknet-pathfinder","text":"Hacknet Pathfinder is a cross-platform modding system for Hacknet.","title":"Hacknet Pathfinder"},{"location":"#automatic-install","text":"Run the Hacknet Pathfinder installer, downloadable from: Github For Windows, run PathfinderInstaller.exe For Linux, run PathfinderInstaller.py","title":"Automatic Install"},{"location":"#manual-install","text":"Download Hacknet Pathfinder's zipped files from Github . Extract the contents into Hacknet's folder. Run PathfinderPatcher.exe (For Linux users, mono PathfinderPatcher.exe ). (For Linux) Copy Hacknet.bin.x86(_64) to HacknetPathfinder.bin.x86(_64) and make StartPathfinder.sh executable. Run HacknetPathfinder.exe on Windows or StartPathfinder.sh on Linux to start Pathfinder.","title":"Manual Install"},{"location":"#running","text":"Hacknet Pathfinder runs as normal Hacknet, there is no change.","title":"Running"},{"location":"#installing-global-mods","text":"Move the global mod contents into Hacknet/BepInEx/plugins .","title":"Installing global mods"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#windows-systemnotsupportedexception-on-launch","text":"More precisely: System.NotSupportedException: An attempt was made to load an assembly from a network location which would have caused the assembly to be sandboxed in previous versions of the .NET Framework Solution: unblock all .dll files provided by Hacknet Pathfinder. This can be done manually by rightclicking each .dll files and editing their properties, or running the following Powershell command: get-childitem \"HACKNET-FOLDER-HERE\" | unblock-file","title":"[Windows] System.NotSupportedException on launch"},{"location":"contributing/","text":"Contributing Compiling and installing Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild 1 or xbuild in root folder or specically against PathfinderPatcher.csproj) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild 1 or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins Adding features Branch off the master branch, program your feature and send the dev team a Pull Request! msbuild is broken on Arch unless you use mono-git from the AUR, see this bug report . \u21a9 \u21a9","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#compiling-and-installing","text":"Clone from source Hacknet Pathfinder https://github.com/Arkhist/Hacknet-Pathfinder Compile PathfinderPatcher ( msbuild 1 or xbuild in root folder or specically against PathfinderPatcher.csproj) Move PathfinderPatcher/bin/Debug/PathfinderPatcher.exe to Hacknet's root directory Run PathfinderPatcher.exe in the root Hacknet directory to obtain HacknetPathfinder.exe Move HacknetPathfinder.exe and FNA.dll to the Pathfinder libs folder. Compile the rest of the project ( msbuild 1 or xbuild in root folder) Copy everything in BepInEx.Hacknet/bin/Debug into Hacknet/BepInEx/core . Copy PathfinderAPI/bin/PathfinderAPI.dll into Hacknet/BepInEx/plugins","title":"Compiling and installing"},{"location":"contributing/#adding-features","text":"Branch off the master branch, program your feature and send the dev team a Pull Request! msbuild is broken on Arch unless you use mono-git from the AUR, see this bug report . \u21a9 \u21a9","title":"Adding features"},{"location":"guides/guibasics/","text":"Hacknet GUI Basics This guide will go over the basics you need to know for handling GUI in Hacknet. For sake of example, we'll be doing everything relating to the GUI in a daemon. For now, we can use the example daemon . [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); } } [!] X/FNA Tip - Drawing Frames FNA's draw method runs every frame . That means if the game is running at 60fps, then whatever you put in draw will fire sixty times every second. If you need to handle logic, it's better to put it in Update , but we'll get to that later. Don't worry about registering the daemon; the class attribute ( Pathfinder.Meta.Load.Daemon ) will do it for us automagically. (That's your word of the day!) Anywho. Now that we've got the daemon set up, let's get started with some basic GUI stuff. Let's draw a square! If you've read the docs, then you'll know we can do this with RenderedRectangle . We'll just be creating a 100x100 rectangle, but there is something we'll need to cover; bounds. When drawing in a section of the screen, such as a daemon or executable, you'll want to draw inside of its bounds . This is basically a Rectangle that is fit to where the content should be. You'll want to draw inside these bounds, because Hacknet uses global positioning for drawing stuff. This means, for example, if you want to draw something 10 pixels from the left of a daemon display, you'd need to offset 10 pixels from the daemons bounds.X . Topic 1: Rectangles Let's say we want a 100x100 square that's 10 pixels from the top-left of the daemon. How would we do it? Give it a shot yourself; and then come back when you think you've got the answer. Back? Great! Here's what I did, personally; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); RenderedRectangle.doRectangle(bounds.X + 10, bounds.Y + 10, 100, 100, Color.White); } Yep, it's that easy. Now, when you put this daemon in a node (via <CustomDaemon/> ), you'll see the rectangle you drew. Doesn't it look beautiful? Oh, also, congratulations! You're a Pathfinder mod developer now! This method is how you'd also draw things in an executable. However, before we give ourselves a pat on the back, we need to remember something! Hacknet is played by many different people, all with different types of screens. In other words, we should also size our stuff dynamically. For this, we can use bounds.Width and bounds.Height . In our case, we want to make a square. This means we can use the same value for width and height. Let's use... the bound's height. We don't want the square to be huge , so let's get, say, 10% of the height. Again, try this yourself before moving on! public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); RenderedRectangle.doRectangle(bounds.X + 10, bounds.Y + 10, bounds.Height * 0.1f, bounds.Height * 0.1f, Color.White); } ( NOTE : This can also be written as bounds.Height / 10f , but either works. I prefer multiplication most of the time, but to each their own.) Now that we're using percents of the display, this will look the same on all displays, for the most part. If we were to use the bound's width, it wouldn't be a huge worry, but it might look too big on ultrawide screens. Anyway, now you can pat yourself on the back; your daemon will look almost identical on every display. Hooray for parity! Topic 2: Buttons Now, let's get a tiny bit more advanced, and create a button with a counter. It might be a good idea to clear the draw function again; but it's up to you. Buttons will be very useful to you moving forward; it's basically the main way a user interacts with daemons, and sometimes even executables! We'll be creating an easy button, just one that tracks how many times we've clicked it. We'll also be throwing a dash of text labels in here for good measure. Don't worry - nothing too serious! I won't explain how buttons work here - the documentation page linked above already does that. I will explain how to place them, though you will soon see it is not all different from how rectangles are placed. Let's create a pretty simple button that's 25 pixels offset from the top-left of the daemon bounds. Feel free to make it however big you want - I'll make mine half of the daemon's width, and 50px high. (Yes, the height is constant, but it's so small; so it's negligible in this context.) Additionally, we'll be using PFButton to get the button ID using GetNextID . This is best defined as a class field. (Don't forget to add using Pathfinder.GUI; to the top of your code!) int buttonID = PFButton.GetNextID(); public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); } We'll also need to keep track of how many times the button is clicked, so let's define an int named counter as a class field. Additionally, let's store the button's value as a bool . We'll use that to create an if statement that will add to counter when true . int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); if(buttonPressed) { counter++; } } Now, the button will add to the counter variable every time it is clicked. Wunderbar! (That's your German word of the day!) However, we have no way of showing the value of the counter. So, let's create a label that will show the value of counter. I'll be using a string template here, but feel free to show it however you like. int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Vector2 textPosition = new Vector2(bounds.X + 25, bounds.Y + 100); string labelText = $\"The button has been pressed {counter} time(s)!\"; bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); TextItem.doLabel(textPosition, labelText, Color.White); if(buttonPressed) { counter++; } } [!] C# Tip - Interpolating Strings Those coming from other languages might be more familiar with string concatenation. However, generally, string interpolation makes cleaner code. You can learn more about string interpolation in the Microsoft docs . When you click the button, you should see the text update in real-time now. The more you click the button, the higher the value gets! Again, buttons can be used in this same manner in executables, as well. Overall, here's what our example daemon looks like: [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Vector2 textPosition = new Vector2(bounds.X + 25, bounds.Y + 100); string labelText = $\"The button has been pressed {counter} time(s)!\"; bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); TextItem.doLabel(textPosition, labelText, Color.White); if(buttonPressed) { counter++; } } } And the result: Congratulations! \ud83c\udf89 Pat yourself on the back again, you are now familiar with the basics of Hacknet's GUI system. You can only get better from here - the sky's the limit!","title":"GUI Basics"},{"location":"guides/guibasics/#xfna-tip-drawing-frames","text":"FNA's draw method runs every frame . That means if the game is running at 60fps, then whatever you put in draw will fire sixty times every second. If you need to handle logic, it's better to put it in Update , but we'll get to that later. Don't worry about registering the daemon; the class attribute ( Pathfinder.Meta.Load.Daemon ) will do it for us automagically. (That's your word of the day!) Anywho. Now that we've got the daemon set up, let's get started with some basic GUI stuff. Let's draw a square! If you've read the docs, then you'll know we can do this with RenderedRectangle . We'll just be creating a 100x100 rectangle, but there is something we'll need to cover; bounds. When drawing in a section of the screen, such as a daemon or executable, you'll want to draw inside of its bounds . This is basically a Rectangle that is fit to where the content should be. You'll want to draw inside these bounds, because Hacknet uses global positioning for drawing stuff. This means, for example, if you want to draw something 10 pixels from the left of a daemon display, you'd need to offset 10 pixels from the daemons bounds.X .","title":"[!] X/FNA Tip - Drawing Frames"},{"location":"guides/guibasics/#topic-1-rectangles","text":"Let's say we want a 100x100 square that's 10 pixels from the top-left of the daemon. How would we do it? Give it a shot yourself; and then come back when you think you've got the answer. Back? Great! Here's what I did, personally; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); RenderedRectangle.doRectangle(bounds.X + 10, bounds.Y + 10, 100, 100, Color.White); } Yep, it's that easy. Now, when you put this daemon in a node (via <CustomDaemon/> ), you'll see the rectangle you drew. Doesn't it look beautiful? Oh, also, congratulations! You're a Pathfinder mod developer now! This method is how you'd also draw things in an executable. However, before we give ourselves a pat on the back, we need to remember something! Hacknet is played by many different people, all with different types of screens. In other words, we should also size our stuff dynamically. For this, we can use bounds.Width and bounds.Height . In our case, we want to make a square. This means we can use the same value for width and height. Let's use... the bound's height. We don't want the square to be huge , so let's get, say, 10% of the height. Again, try this yourself before moving on! public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); RenderedRectangle.doRectangle(bounds.X + 10, bounds.Y + 10, bounds.Height * 0.1f, bounds.Height * 0.1f, Color.White); } ( NOTE : This can also be written as bounds.Height / 10f , but either works. I prefer multiplication most of the time, but to each their own.) Now that we're using percents of the display, this will look the same on all displays, for the most part. If we were to use the bound's width, it wouldn't be a huge worry, but it might look too big on ultrawide screens. Anyway, now you can pat yourself on the back; your daemon will look almost identical on every display. Hooray for parity!","title":"Topic 1: Rectangles"},{"location":"guides/guibasics/#topic-2-buttons","text":"Now, let's get a tiny bit more advanced, and create a button with a counter. It might be a good idea to clear the draw function again; but it's up to you. Buttons will be very useful to you moving forward; it's basically the main way a user interacts with daemons, and sometimes even executables! We'll be creating an easy button, just one that tracks how many times we've clicked it. We'll also be throwing a dash of text labels in here for good measure. Don't worry - nothing too serious! I won't explain how buttons work here - the documentation page linked above already does that. I will explain how to place them, though you will soon see it is not all different from how rectangles are placed. Let's create a pretty simple button that's 25 pixels offset from the top-left of the daemon bounds. Feel free to make it however big you want - I'll make mine half of the daemon's width, and 50px high. (Yes, the height is constant, but it's so small; so it's negligible in this context.) Additionally, we'll be using PFButton to get the button ID using GetNextID . This is best defined as a class field. (Don't forget to add using Pathfinder.GUI; to the top of your code!) int buttonID = PFButton.GetNextID(); public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); } We'll also need to keep track of how many times the button is clicked, so let's define an int named counter as a class field. Additionally, let's store the button's value as a bool . We'll use that to create an if statement that will add to counter when true . int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); if(buttonPressed) { counter++; } } Now, the button will add to the counter variable every time it is clicked. Wunderbar! (That's your German word of the day!) However, we have no way of showing the value of the counter. So, let's create a label that will show the value of counter. I'll be using a string template here, but feel free to show it however you like. int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Vector2 textPosition = new Vector2(bounds.X + 25, bounds.Y + 100); string labelText = $\"The button has been pressed {counter} time(s)!\"; bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); TextItem.doLabel(textPosition, labelText, Color.White); if(buttonPressed) { counter++; } }","title":"Topic 2: Buttons"},{"location":"guides/guibasics/#c-tip-interpolating-strings","text":"Those coming from other languages might be more familiar with string concatenation. However, generally, string interpolation makes cleaner code. You can learn more about string interpolation in the Microsoft docs . When you click the button, you should see the text update in real-time now. The more you click the button, the higher the value gets! Again, buttons can be used in this same manner in executables, as well. Overall, here's what our example daemon looks like: [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; int buttonID = PFButton.GetNextID(); int counter = 0; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); Vector2 textPosition = new Vector2(bounds.X + 25, bounds.Y + 100); string labelText = $\"The button has been pressed {counter} time(s)!\"; bool buttonPressed = Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, bounds.Width / 2, 50, \"Add to Counter\", Color.White); TextItem.doLabel(textPosition, labelText, Color.White); if(buttonPressed) { counter++; } } } And the result: Congratulations! \ud83c\udf89 Pat yourself on the back again, you are now familiar with the basics of Hacknet's GUI system. You can only get better from here - the sky's the limit!","title":"[!] C# Tip - Interpolating Strings"},{"location":"hndocs/gui/","text":"Hacknet.GUI Documentation relating to Hacknet's GUI functions. Table of Contents: Buttons CheckBoxes Rectangles TextItem","title":"GUI"},{"location":"hndocs/gui/#table-of-contents","text":"Buttons CheckBoxes Rectangles TextItem","title":"Table of Contents:"},{"location":"hndocs/gui/Buttons/","text":"Buttons Buttons are essentially just boxes that return a boolean value relating to whether or not it has been pressed. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Button.doButton(int id, int x, int y, int width, int height, string text, Color? color); Button.doButton will create a simple button (similar to the rest of the UI) that will return a bool value of whether or not it has been clicked. Like every other UI element, this should be put in a draw function. Each button must have a unique id . If multiple buttons share the same ID, then clicking on one of them will act as clicking on all of them. You can simplify this with Pathfinder via PFButton ( Pathfinder.GUI ) by declaring the button ID in a class field: using Hacknet; using Hacknet.Gui; using Pathfinder.GUI; using Microsoft.Xna.Framework; public class SomeClass { public int buttonID = PFButton.GetNextID(); public override void draw(float t) { Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red) } } color determines the color of the tiny rectangle next to the text in buttons, not the button itself. An example of how a button might be used is in an executable to exit the executable. For example: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... bool exitButton = Button.doButton(183738, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red); if(exitButton) { this.isExiting = true; return; } You can obviously compact this code to make it look nicer as; this.isExiting = Button.doButton(183738, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red); ...but the above example works for those still fairly new to C#. Unused Buttons These buttons are largely unused in the modding scene, but you may still find use in them: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Button.doHoldDownButton(int id, int x, int y, int width, int height, string text, bool hasOutline, Color? outlineColor, Color? selectedColor);","title":"Buttons"},{"location":"hndocs/gui/Buttons/#buttons","text":"Buttons are essentially just boxes that return a boolean value relating to whether or not it has been pressed. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Button.doButton(int id, int x, int y, int width, int height, string text, Color? color); Button.doButton will create a simple button (similar to the rest of the UI) that will return a bool value of whether or not it has been clicked. Like every other UI element, this should be put in a draw function. Each button must have a unique id . If multiple buttons share the same ID, then clicking on one of them will act as clicking on all of them. You can simplify this with Pathfinder via PFButton ( Pathfinder.GUI ) by declaring the button ID in a class field: using Hacknet; using Hacknet.Gui; using Pathfinder.GUI; using Microsoft.Xna.Framework; public class SomeClass { public int buttonID = PFButton.GetNextID(); public override void draw(float t) { Button.doButton(buttonID, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red) } } color determines the color of the tiny rectangle next to the text in buttons, not the button itself. An example of how a button might be used is in an executable to exit the executable. For example: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... bool exitButton = Button.doButton(183738, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red); if(exitButton) { this.isExiting = true; return; } You can obviously compact this code to make it look nicer as; this.isExiting = Button.doButton(183738, bounds.X + 25, bounds.Y + 25, 100, 100, \"Exit\", Color.Red); ...but the above example works for those still fairly new to C#.","title":"Buttons"},{"location":"hndocs/gui/Buttons/#unused-buttons","text":"These buttons are largely unused in the modding scene, but you may still find use in them: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Button.doHoldDownButton(int id, int x, int y, int width, int height, string text, bool hasOutline, Color? outlineColor, Color? selectedColor);","title":"Unused Buttons"},{"location":"hndocs/gui/CheckBoxes/","text":"CheckBoxes Checkboxes in Hacknet work very similarly to Buttons in the sense that they return a bool value relating to whether or not the box has been clicked. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... CheckBox.doCheckBox(int id, int x, int y, bool isChecked, Color? selectedColor); Since the checkboxes themselves do not track whether or not they've been checked, it would be up to you to determine this. You can do this with, say, a class field. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... public class SomeClass { public bool checkboxIsChecked = false; public override void draw(float t) { bool checkbox = CheckBox.doCheckBox(182939, 100, 100, checkboxIsChecked); if(checkbox) { checkboxIsChecked = !checkboxIsChecked; } } } You can also add text to checkboxes: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... CheckBox.doCheckBox(182939, 100, 100, false, Color.White, \"Some Text Here\");","title":"CheckBoxes"},{"location":"hndocs/gui/CheckBoxes/#checkboxes","text":"Checkboxes in Hacknet work very similarly to Buttons in the sense that they return a bool value relating to whether or not the box has been clicked. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... CheckBox.doCheckBox(int id, int x, int y, bool isChecked, Color? selectedColor); Since the checkboxes themselves do not track whether or not they've been checked, it would be up to you to determine this. You can do this with, say, a class field. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... public class SomeClass { public bool checkboxIsChecked = false; public override void draw(float t) { bool checkbox = CheckBox.doCheckBox(182939, 100, 100, checkboxIsChecked); if(checkbox) { checkboxIsChecked = !checkboxIsChecked; } } } You can also add text to checkboxes: using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... CheckBox.doCheckBox(182939, 100, 100, false, Color.White, \"Some Text Here\");","title":"CheckBoxes"},{"location":"hndocs/gui/Rectangles/","text":"Rectangles Basic rectangles. These can be any solid color. using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangle(int x, int y, int width, int height, Color color = Color.White, bool blocking = false); Creates a simple rectangle to be drawn on the screen. color determines what the fill color of the rectangle will be. blocking determines whether or not the rectangle should block input, such as mouse clicks. An example rectangle would be: using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangle(0, 0, 500, 250, Color.Orange); This will create an orange rectangle at the top left of the screen that is 500 pixels wide and 250 pixels tall. Rectangle Outlines Same usage as above, but specifically for outlines. using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangleOutline(int x, int y, int width, int height, int thickness, Color color = Color.White); thickness determines how thick the outline should be, in pixels.","title":"Rectangles"},{"location":"hndocs/gui/Rectangles/#rectangles","text":"Basic rectangles. These can be any solid color. using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangle(int x, int y, int width, int height, Color color = Color.White, bool blocking = false); Creates a simple rectangle to be drawn on the screen. color determines what the fill color of the rectangle will be. blocking determines whether or not the rectangle should block input, such as mouse clicks. An example rectangle would be: using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangle(0, 0, 500, 250, Color.Orange); This will create an orange rectangle at the top left of the screen that is 500 pixels wide and 250 pixels tall.","title":"Rectangles"},{"location":"hndocs/gui/Rectangles/#rectangle-outlines","text":"Same usage as above, but specifically for outlines. using Hacknet; using Hacknet.Gui; // ... RenderedRectangle.doRectangleOutline(int x, int y, int width, int height, int thickness, Color color = Color.White); thickness determines how thick the outline should be, in pixels.","title":"Rectangle Outlines"},{"location":"hndocs/gui/TextItem/","text":"TextItem TextItem is the main way to make \"labels\" in Hacknet, which allow you to show text. This documentation will show how to make a simple label, and then list other ways. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... TextItem.doLabel(Vector2 position, string text, Color? color); This will create a simple label that uses the default font to display text. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Vector2 pos = new Vector2(100, 100); TextItem.doLabel(pos, \"Some text\", Color.White); Hacknet also has built-in functions for creating labels with small font and tiny font: TextItem.doSmallLabel(Vector2 position, string text, Color? color); TextItem.doTinyLabel(Vector2 position, string text, Color? color); For more advanced text methods, please refer to the Advanced Text Guide .","title":"TextItem"},{"location":"hndocs/gui/TextItem/#textitem","text":"TextItem is the main way to make \"labels\" in Hacknet, which allow you to show text. This documentation will show how to make a simple label, and then list other ways. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... TextItem.doLabel(Vector2 position, string text, Color? color); This will create a simple label that uses the default font to display text. using Hacknet; using Hacknet.Gui; using Microsoft.Xna.Framework; // ... Vector2 pos = new Vector2(100, 100); TextItem.doLabel(pos, \"Some text\", Color.White); Hacknet also has built-in functions for creating labels with small font and tiny font: TextItem.doSmallLabel(Vector2 position, string text, Color? color); TextItem.doTinyLabel(Vector2 position, string text, Color? color); For more advanced text methods, please refer to the Advanced Text Guide .","title":"TextItem"},{"location":"mod/actions/","text":"Custom actions Base action public class CustomAction : Pathfinder.Action.PathfinderAction { [XMLStorage] public string Attribute1; [XMLStorage] public string Attribute2 = \"Default value!\"; public override void Trigger (object os_obj) { OS os = (OS)os_obj; os.write(\"Custom action triggered!\"); os.write(Attribute1); os.write(Attribute2); } } Delayable action DelayablePathfinderAction is a subtype of PathfinderAction that implements the DelayHost and Delay attributes. public class CustomDelayableAction : Pathfinder.Action.DelayablePathfinderAction { public override void Trigger (OS os) { if (DelayHost != null) { os.write(\"Custom action triggered after \" + Delay + \" seconds with host \" + DelayHost + \"!\"); } } } Registration Actions can be registered manually or with the Action attribute. Pathfinder.Action.ActionManager.RegisterAction<CustomAction>(\"CustomActionXMLTag\"); [Pathfinder.Meta.Load.Action(\"CustomActionXMLTag\")] public class CustomAction : PathfinderAction Adding a custom action to an actions file <CustomActionXMLTag Attribute1=\"Value\" />","title":"Actions"},{"location":"mod/actions/#custom-actions","text":"","title":"Custom actions"},{"location":"mod/actions/#base-action","text":"public class CustomAction : Pathfinder.Action.PathfinderAction { [XMLStorage] public string Attribute1; [XMLStorage] public string Attribute2 = \"Default value!\"; public override void Trigger (object os_obj) { OS os = (OS)os_obj; os.write(\"Custom action triggered!\"); os.write(Attribute1); os.write(Attribute2); } }","title":"Base action"},{"location":"mod/actions/#delayable-action","text":"DelayablePathfinderAction is a subtype of PathfinderAction that implements the DelayHost and Delay attributes. public class CustomDelayableAction : Pathfinder.Action.DelayablePathfinderAction { public override void Trigger (OS os) { if (DelayHost != null) { os.write(\"Custom action triggered after \" + Delay + \" seconds with host \" + DelayHost + \"!\"); } } }","title":"Delayable action"},{"location":"mod/actions/#registration","text":"Actions can be registered manually or with the Action attribute. Pathfinder.Action.ActionManager.RegisterAction<CustomAction>(\"CustomActionXMLTag\"); [Pathfinder.Meta.Load.Action(\"CustomActionXMLTag\")] public class CustomAction : PathfinderAction","title":"Registration"},{"location":"mod/actions/#adding-a-custom-action-to-an-actions-file","text":"<CustomActionXMLTag Attribute1=\"Value\" />","title":"Adding a custom action to an actions file"},{"location":"mod/administrators/","text":"Custom administrators New administrators public class CustomAdministrator : Pathfinder.Administrator.BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } } Registration Administrator can be registered manually or with the Administrator attribute. Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>(); [Pathfinder.Meta.Load.Administrator] public class CustomAdministrator : BaseAdministrator Adding a custom administrator to a computer <admin type=\"CustomAdministrator\" />","title":"Administrators"},{"location":"mod/administrators/#custom-administrators","text":"","title":"Custom administrators"},{"location":"mod/administrators/#new-administrators","text":"public class CustomAdministrator : Pathfinder.Administrator.BaseAdministrator { public CustomAdministrator(Computer computer, OS opSystem) : base(computer, opSystem) { } public override void disconnectionDetected(Computer c, OS os) { } public override void traceEjectionDetected(Computer c, OS os) { } }","title":"New administrators"},{"location":"mod/administrators/#registration","text":"Administrator can be registered manually or with the Administrator attribute. Pathfinder.Administrator.AdministratorManager.RegisterAdministrator<CustomAdministrator>(); [Pathfinder.Meta.Load.Administrator] public class CustomAdministrator : BaseAdministrator","title":"Registration"},{"location":"mod/administrators/#adding-a-custom-administrator-to-a-computer","text":"<admin type=\"CustomAdministrator\" />","title":"Adding a custom administrator to a computer"},{"location":"mod/commands/","text":"Creating custom commands New command public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); } Registration Commands can be registered manually or with the Command attribute. Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); [Pathfinder.Meta.Load.Command(\"CommandName\")] public static void TestCommand(OS os, string[] args) Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Commands"},{"location":"mod/commands/#creating-custom-commands","text":"","title":"Creating custom commands"},{"location":"mod/commands/#new-command","text":"public static void TestCommand(OS os, string[] args) { os.write(\"Arguments passed in: \" + string.Join(\" \", args)); }","title":"New command"},{"location":"mod/commands/#registration","text":"Commands can be registered manually or with the Command attribute. Pathfinder.Command.CommandManager.RegisterCommand(\"CommandName\", TestCommand); [Pathfinder.Meta.Load.Command(\"CommandName\")] public static void TestCommand(OS os, string[] args) Typing CommandName in the in-game terminal will now print \"Arguments passed in...\".","title":"Registration"},{"location":"mod/conditions/","text":"Custom conditions New conditions public class CustomCondition : Pathfinder.Action.PathfinderCondition { [XMLStorage] public string Attribute; public override bool Check(object os_obj) { OS os = (OS)os_obj; // return true if actions inside condition should be triggered // return false otherwise } } Registration Conditions can be registered manually or with the Condition attribute. Pathfinder.Action.ConditionManager.RegisterCondition<CustomCondition>(\"CustomConditionXMLTag\"); [Pathfinder.Meta.Load.Condition] public class CustomCondition : PathfinderCondition Adding a custom condition to an actions file <CustomConditionXMLTag Attribue=\"value\"> <!-- Actions go here! --> </CustomConditionXMLTag>","title":"Conditions"},{"location":"mod/conditions/#custom-conditions","text":"","title":"Custom conditions"},{"location":"mod/conditions/#new-conditions","text":"public class CustomCondition : Pathfinder.Action.PathfinderCondition { [XMLStorage] public string Attribute; public override bool Check(object os_obj) { OS os = (OS)os_obj; // return true if actions inside condition should be triggered // return false otherwise } }","title":"New conditions"},{"location":"mod/conditions/#registration","text":"Conditions can be registered manually or with the Condition attribute. Pathfinder.Action.ConditionManager.RegisterCondition<CustomCondition>(\"CustomConditionXMLTag\"); [Pathfinder.Meta.Load.Condition] public class CustomCondition : PathfinderCondition","title":"Registration"},{"location":"mod/conditions/#adding-a-custom-condition-to-an-actions-file","text":"<CustomConditionXMLTag Attribue=\"value\"> <!-- Actions go here! --> </CustomConditionXMLTag>","title":"Adding a custom condition to an actions file"},{"location":"mod/daemons/","text":"Creating custom daemons Base daemon public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } } Registration Daemons can be registered manually or with the Daemon attribute. Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>(); [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon XML Storage XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString; Adding a custom daemon to a computer <CustomDaemon DisplayString=\"XML Edited test\" />","title":"Daemons"},{"location":"mod/daemons/#creating-custom-daemons","text":"","title":"Creating custom daemons"},{"location":"mod/daemons/#base-daemon","text":"public class CustomDaemon : Pathfinder.Daemon.BaseDaemon { public CustomDaemon(Computer computer, string serviceName, OS opSystem) : base(computer, serviceName, opSystem) { } public override string Identifier => \"Custom Daemon\"; [XMLStorage] public string DisplayString = \"Default text\"; public override void draw(Rectangle bounds, SpriteBatch sb) { base.draw(bounds, sb); var center = os.display.bounds.Center; Hacknet.Gui.TextItem.doLabel(new Vector2(center.X, center.Y), DisplayString, Color.Aquamarine); } }","title":"Base daemon"},{"location":"mod/daemons/#registration","text":"Daemons can be registered manually or with the Daemon attribute. Pathfinder.Daemon.DaemonManager.RegisterDaemon<CustomDaemon>(); [Pathfinder.Meta.Load.Daemon] public class CustomDaemon : Pathfinder.Daemon.BaseDaemon","title":"Registration"},{"location":"mod/daemons/#xml-storage","text":"XMLStorage variables are string variables that can be specified in the Daemon's XML. In the code: [XMLStorage] public string DisplayString;","title":"XML Storage"},{"location":"mod/daemons/#adding-a-custom-daemon-to-a-computer","text":"<CustomDaemon DisplayString=\"XML Edited test\" />","title":"Adding a custom daemon to a computer"},{"location":"mod/executables/","text":"Creating custom executables New executables public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; this.IdentifierName = \"ExecName\"; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } } GameExecutable Implemented, not documented yet. Registration Executables can be registered manually or with the Executable attribute. Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); [Pathfinder.Meta.Load.Executable(\"#PF_BASIC_EXE#\")] public class BasicExecutable : Pathfinder.Executable.BaseExecutable The provided argument corresponds to the replacement tag for extension files. Executable features Exiting Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; } Opening a port, starting a trace The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken(); Drawing in the executable's area The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Executables"},{"location":"mod/executables/#creating-custom-executables","text":"","title":"Creating custom executables"},{"location":"mod/executables/#new-executables","text":"public class BasicExecutable : Pathfinder.Executable.BaseExecutable { public BasicExecutable(Rectangle location, OS operatingSystem, string[] args) : base(location, operatingSystem, args) { this.ramCost = 761; this.IdentifierName = \"ExecName\"; } public override void LoadContent() { base.LoadContent(); } public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); } private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; } }","title":"New executables"},{"location":"mod/executables/#gameexecutable","text":"Implemented, not documented yet.","title":"GameExecutable"},{"location":"mod/executables/#registration","text":"Executables can be registered manually or with the Executable attribute. Pathfinder.Executable.ExecutableManager.RegisterExecutable<BasicExecutable>(\"#PF_BASIC_EXE#\"); [Pathfinder.Meta.Load.Executable(\"#PF_BASIC_EXE#\")] public class BasicExecutable : Pathfinder.Executable.BaseExecutable The provided argument corresponds to the replacement tag for extension files.","title":"Registration"},{"location":"mod/executables/#executable-features","text":"","title":"Executable features"},{"location":"mod/executables/#exiting","text":"Setting isExiting to true will close the executable slowly. Setting needsRemoval to true will close the executable instantly. Example: private float lifetime = 0f; public override void Update(float t) { base.Update(t); lifetime += t; if (lifetime > 2.5f) isExiting = true; }","title":"Exiting"},{"location":"mod/executables/#opening-a-port-starting-a-trace","text":"The executable has access to the OS object os (interface with the game), thisComputer (the player's computer) and targetIP , the IP the player was connected to on executable launch (See this page for a list of all the included port protocols). Programs.getComputer(os, targetIP).openPort(\"ssh\", os.thisComputer.ip); To start a trace, if the computer has security: Programs.getComputer(os, targetIP).hostileActionTaken();","title":"Opening a port, starting a trace"},{"location":"mod/executables/#drawing-in-the-executables-area","text":"The Hacknet.Gui namespace contains most of the drawing functions. public override void Draw(float t) { base.Draw(t); drawTarget(); drawOutline(); Hacknet.Gui.TextItem.doLabel(new Vector2(Bounds.Center.X, Bounds.Center.Y), \"blue text\", new Color(255, 0, 0)); }","title":"Drawing in the executable's area"},{"location":"mod/missions/","text":"Custom missions goals New mission goals public class CustomMissionGoal : Pathfinder.Mission.PathfinderGoal { [XMLStorage] public string Attribute; public OS os; public CustomMissionGoal() { os = OS.currentInstance; } public override bool isComplete(List<string> additionalDetails = null) { // return true if the mission should be completed // return false otherwise } } Registration Goals can be registered manually or with the Goal attribute. Pathfinder.Goal.GoalManager.RegisterGoal<CustomMissionGoal>(\"CustomGoalName\"); [Pathfinder.Meta.Load.Goal(\"CustomGoalName\")] public class CustomMissionGoal : PathfinderGoal Adding a custom goal to a mission file <goal type=\"CustomGoalName\" Attribute=\"attribute value\" />","title":"Missions"},{"location":"mod/missions/#custom-missions-goals","text":"","title":"Custom missions goals"},{"location":"mod/missions/#new-mission-goals","text":"public class CustomMissionGoal : Pathfinder.Mission.PathfinderGoal { [XMLStorage] public string Attribute; public OS os; public CustomMissionGoal() { os = OS.currentInstance; } public override bool isComplete(List<string> additionalDetails = null) { // return true if the mission should be completed // return false otherwise } }","title":"New mission goals"},{"location":"mod/missions/#registration","text":"Goals can be registered manually or with the Goal attribute. Pathfinder.Goal.GoalManager.RegisterGoal<CustomMissionGoal>(\"CustomGoalName\"); [Pathfinder.Meta.Load.Goal(\"CustomGoalName\")] public class CustomMissionGoal : PathfinderGoal","title":"Registration"},{"location":"mod/missions/#adding-a-custom-goal-to-a-mission-file","text":"<goal type=\"CustomGoalName\" Attribute=\"attribute value\" />","title":"Adding a custom goal to a mission file"},{"location":"mod/ports/","text":"Ports Extension development Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp Protocol list Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32 Plugin development Adding new port defaults You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML. Ports can also be added by using the Port attribute on a field or property. [Pathfinder.Meta.Load.Port] public Pathfinder.Port.PortRecord customPort = new Pathfinder.Port.PortRecord(\"protocol\", \"displayName\", 50); Reading port data Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Ports"},{"location":"mod/ports/#ports","text":"","title":"Ports"},{"location":"mod/ports/#extension-development","text":"Pathfinder includes a new syntax for registering ports on a computer, which looks like this: <PFPorts replace=\"true\">ssh ftp:50 random_protocol:78:display_name_underscores_are_spaces</PFPorts> Using replace=\"true\" makes it so that the Pathfinder ports list will replace the vanilla ports list when read, otherwise it will append to the port list. Putting the vanilla ports element after PFPorts will always append, no matter what is set here. In order, the parameters are: The protocol name, all lowercase as a convention The port number if you don't want the default The display name of the port when shown to the user, eg. FTP Server is the default for ftp","title":"Extension development"},{"location":"mod/ports/#protocol-list","text":"Here's a list of all the protocol names and their default ports included with Pathfinder: ssh 22 ftp 21 smtp 25 web 80 sql 1433 medical 104 torrent 6881 ssl 443 pacific 192 rtsp 554 transfer 211 version 9418 blizzard 3724 eos 3659 sigscramble 32","title":"Protocol list"},{"location":"mod/ports/#plugin-development","text":"","title":"Plugin development"},{"location":"mod/ports/#adding-new-port-defaults","text":"You can add a new default with Pathfinder.Port.PortManager.RegisterPort(string protocol, string displayName, int defaultPort) . The last parameter is optional, and if you omit it you will always have to specify a port number in XML. Ports can also be added by using the Port attribute on a field or property. [Pathfinder.Meta.Load.Port] public Pathfinder.Port.PortRecord customPort = new Pathfinder.Port.PortRecord(\"protocol\", \"displayName\", 50);","title":"Adding new port defaults"},{"location":"mod/ports/#reading-port-data","text":"Ports are handled differently in Pathfinder than in the base game, which means you should try to ignore most of what you might see while decompiling. DO NOT USE Computer.ports , Computer.portsOpen , or Computer.portRemapping ! None of these are populated any more, and will not give you any information! If you want to interface with ports, please add using Pathfinder.Port; to the top of your .cs files, and use the extension methods like so: using BepInEx; using BepInEx.Hacknet; using Pathfinder.Port; [BepInPlugin(\"PortsExampleGuid\", \"plugin name\", \"0.0.1\")] public class SomePlugin { public override bool Load() { Pathfinder.Command.CommandManager.RegisterCommand(\"openallifssh\", (os, args) => { if (os.connectedComp?.isPortOpen(\"ssh\") ?? false) { foreach (var port in os.connectedComp.GetAllPorts()) { os.connectedComp.openPort(port.Protocol, os.thisComputer.ip); } } }); } } This command would open all ports on the connected computer if there's a port open that uses the ssh protocol. It's preferred to always use the protocol names and not the port numbers, and it is required for some methods except for the base game ports.","title":"Reading port data"},{"location":"mod/start/","text":"Getting started with Pathfinder Modding Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.5 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started"},{"location":"mod/start/#getting-started-with-pathfinder-modding","text":"Use this template or follow the steps below. Start a new .NET library project with .NET Framework 4.5 Link it against the HacknetPathfinder.exe ( Hacknet.exe if you installed Pathfinder), PathfinderAPI.dll , FNA.dll , BepInEx.Core.dll , and BepInEx.Hacknet.dll . You may need more than this, but that's the reccomended set to begin on a simple mod. You may need to go into the project options and set the project to target the x86 platform Create a class that inherits from BepInEx.Hacknet.HacknetPlugin , and add the BepInEx.BepInPlugin attribute to it with a name, guid, and version. using BepInEx; using BepInEx.Hacknet; namespace HacknetPluginTemplate { [BepInPlugin(ModGUID, ModName, ModVer)] public class HacknetPluginTemplate : HacknetPlugin { public const string ModGUID = \"com.Windows10CE.Template\"; public const string ModName = \"MOD NAME HERE\"; public const string ModVer = \"1.0.0\"; public override bool Load() { return true; } } } And now you have a basic functioning mod, the rest is up to you! All of the \"Register\" calls should be placed in the Load() function of your mod. Install the mod by placing it in Hacknet/BepInEx/plugins or a folder called Plugins in your extension's folder if you want to make it extension-specific.","title":"Getting started with Pathfinder Modding"}]}